\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{listings}
\usepackage{fullpage}

\newcommand{\code}[1]{\lstinline:#1:}
\newcommand{\fun}[1]{\vspace{2mm}\noindent \code{#1}}
\newcommand{\mat}[4]{\left(\begin{matrix}#1&#2\\#3&#4\end{matrix}\right)}

\title{Documentation (in progress)}
\date{\today}

\begin{document}
\lstset{language=C,
  identifierstyle=\bfseries}

\maketitle

\section{\code{acb_mat_extras.h}}

\fun{
void
acb_mat_get_real(arb_mat_t re, const acb_mat_t z);
}

\fun{
void
acb_mat_get_imag(arb_mat_t im, const acb_mat_t z);
}

\fun{
void
acb_mat_set_arb_arb(acb_mat_t z, const arb_mat_t re, const arb_mat_t im);
}

Set z to the complex matrix with real part re and imaginary part im. 

\fun{
void
arb_mat_randtest_precise(arb_mat_t r, flint_rand_t state, slong prec, slong mag_bits);
}

Generate a random real matrix r by calling \code{arb_randtest_precise} on each entry.

\fun{
void
arb_mat_randtest_sym_precise(arb_mat_t r, flint_rand_t state, slong prec, slong mag_bits);
}

Generate a random symmetric real matrix r by calling
\fun{arb_randtest_precise} on each entry in the upper triangular
part.

\fun{
void
arb_mat_randtest_sym_pos(arb_mat_t r, flint_rand_t state, slong prec);
}

Generate a random symmetric positive definite matrix r, obtained as
the exponential of a random symmetric real matrix.

\fun{
int
arb_mat_is_nonsymmetric(const arb_mat_t m);
}

\fun{
void
arb_mat_congr_fmpz_mat(arb_mat_t r, const fmpz_mat_t u, const arb_mat_t m, slong prec);
}

Set r to \code{u^t m u}.

\fun{
int
arb_mat_is_minkowski_reduced(const arb_mat_t r, const arb_t tol, slong prec);
}

Return 1 when the matrix r is approximately Minkowski-reduced, within
a relative error specified by tol (which should be small). The matrix
r is assumed to be square and symmetric. Currently only implemented
for $g\times g$ matrices with $g\in\{1,2\}$.

\fun{
int
arb_mat_minkowski_reduce(arb_mat_t r, fmpz_mat_t u, const arb_mat_t m,
const arb_t tol, slong prec);
}

Attempt to compute an integer matrix u and \code{r = u^t m u} such
that r is approximately Minkowski-reduced, within a relative error
specified by tol. Return 1 upon success; otherwise, return 0. The
matrix r is assumed to be square of size 1 or 2 and symmetric positive
definite.

\fun{
void
arb_mat_lambda(arb_t lambda, const arb_mat_t m, slong prec);
}

Compute a lower bound for the smallest eigenvalue of the symmetric
positive definite matrix m. Currently only implemented for matrices of
size 1 or 2.

\section{siegel.h}

\fun{type sp2gz_struct}

\fun{type sp2gz_t}

An \code{sp2gz_struct} consists an slong g, and four \code{fmpz_mat_struct}
elements a, b, c, d which are square of size g. An \code{sp2gz_t} is defined
as an array of length one of type \code{sp2gz_struct}, permitting an \code{sp2gz_t}
to be passed by reference.

\fun{
void
sp2gz_init(sp2gz_t m, slong g)
}

\fun{
void
sp2gz_clear(sp2gz_t m)
}

\fun{
void
sp2gz_swap(sp2gz_t m, sp2gz_t n)
}

\fun{
void
sp2gz_set(sp2gz_t m, const sp2gz_t n)
}

\fun{
void sp2gz_set_mat(sp2gz_t m, const fmpz_mat_t n);
}

\fun{
void sp2gz_get_mat(fmpz_mat_t m, const sp2gz_t n);
}

Conversions between an \code{sp2gz_t} and an \code{fmpz_mat_t} of size
$2g\times 2g$.

\fun{
  void
sp2gz_one(sp2gz_t m)
}

Set m to the identity.

\fun{
  void
  sp2gz_J(sp2gz_t m)
}

Set m to the matrix defined by blocks as $\mat{0}{1}{-1}{0}$.

\fun{
void sp2gz_fprint(FILE * file, const sp2gz_t m);
}
Print the matrix m to a file. 

\fun{
  void
  sp2gz_print(const sp2gz_t m)
}
Print to stdout.

\fun{
  int
  sp2gz_equal(const sp2gz_t m, const sp2gz_t n)
}

\fun{
void sp2gz_mul(sp2gz_t r, const sp2gz_t m, const sp2gz_t n);
}

\fun{
void sp2gz_inv(sp2gz_t r, const sp2gz_t m);
}
Set r to the inverse of m, assuming that m is indeed a symplectic matrix.

\fun{
int sp2gz_is_one(const sp2gz_t m);
}

\fun{
int sp2gz_is_J(const sp2gz_t m);
}

\fun{
int sp2gz_is_correct(const sp2gz_t m);
}
Return 1 if the matrix m is indeed symplectic, 0 otherwise.

\fun{
void sp2gz_set_diagonal(sp2gz_t m, const fmpz_mat_t u);
}
Set m to the symplectic matrix $\mat{u}{0}{0}{u^{-t}}$. The matrix u must be invertible.

\fun{
void sp2gz_randtest_triangular(sp2gz_t m, flint_rand_t state, slong bits);
}

Set m to a random symplectic matrix of the form $\mat{1}{s}{0}{1}$,
where $s$ is a symmetric integer matrix with entries bounded by bits
in size.

\fun{
void sp2gz_randtest_diagonal(sp2gz_t m, flint_rand_t state, slong bits);
}

Set m to a random symplectic matrix of the form
$\mat{u}{0}{0}{u^{-t}}$ with entries of size approximately bits.

\fun{
void sp2gz_randtest(sp2gz_t m, flint_rand_t state, slong bits);
}

Set $m$ to a random symplectic matrix with entries of size
approximately bits, using a combination of the above two functions.

\fun{
void siegel_halfspace_randtest(acb_mat_t z, flint_rand_t state, slong prec);
}

Set z to a random element of the Siegel half space for genus g with
relative precision approximately prec.

\fun{
void siegel_star(acb_mat_t w, const sp2gz_t m, const acb_mat_t z, slong prec);
}

Compute $w = cz+d$ where c, d are the lower blocks of m.

\fun{
int siegel_transform(acb_mat_t w, const sp2gz_t m, const acb_mat_t z, slong prec);
}

Attempt to compute $w = (az+b)(cz+d)^{-1}$. Return 1 if the inversion
succeeds; otherwise, return 0.

\fun{
int siegel_is_real_reduced(const acb_mat_t z, const arb_t tol, slong prec);
}

Return 1 when the real part of z is reduced within an error bound
specified by tol, and 0 otherwise.

\fun{
int siegel_reduce_real(acb_mat_t w, sp2gz_t u, const acb_mat_t z,
		       const arb_t tol, slong prec);
}

Attempt to reduce the real part of z within an error bound specified
by tol. Return 1 on success, 0 otherwise.

\fun{
slong siegel_nb_test_matrices(slong g);
}

Return the number of matrices used in the reduction to the fundamental
domain in genus g (1 if $g=1$, 19 if $g=2$, not implemented
otherwise).

\fun{ void siegel_test_matrix(sp2gz_t u, slong j); } Set u to the
$j$-th symplectic matrix used in the reduction to the fundamental
domain. Only implemented when $g\in\{1,2\}$.

\fun{
int siegel_fundamental_domain(acb_mat_t w, sp2gz_t m,
			      const acb_mat_t z, const arb_t tol, slong prec);
}

Attempt to compute a symplectic m such that $w = mz$ lies in the
fundamental domain, within a relative error bound specified by
tol. Return 1 on success, 0 otherwise. Only implemented when $g\in\{1,2\}$.

\section{theta.h}

We compute Borchardt means of 4-element arrays only.

\fun{
int acb_sqrt_goodpos(acb_t r, const acb_t z, slong prec);
}

Set r to a square root of z with positive real part and return 1. If
no such square root can be computed, return 0.

\fun{
int borchardt_step(acb_ptr b, acb_srcptr a, slong prec);
}

Set b to the Borchardt iterate of a, where the square roots are chosen
with positive real part, and return 1. If one of these square roots
cannot be computed, return 0.

\fun{
void borchardt_mean_m0(arb_t m0, acb_srcptr a, slong prec);
}

Assuming that 1 is part of the entries of a, compute a lower bound for
a real number m0 with the following property: there exists a line D
passing through the origin such that all entries of a are on the same
side of D and at a distance at least m0 of D. A non-positive return
value indicates failure.

\fun{
void borchardt_mean_M0(arb_t M0, acb_srcptr a, slong prec);
}

Set M0 to an upper bound for the absolute values of the entries of a.

\fun{
void borchardt_mean_Delta0(arb_t Delta0, acb_srcptr a, slong prec);
}

Set Delta0 to an upper bound for $\sum_{i\neq j} |a_i - a_j|$.

\fun{
int borchardt_mean_nb_steps_before_quad_conv(fmpz_t nb, acb_srcptr a, slong prec);
}

Set nb such that the Borchardt sequence starting from a reaches
quadratic convergence after nb steps. Return 1 on success, and 0 if a
positive m0 cannot be computed. Note: this bound is usually very
pessimistic.

\fun{
void borchardt_mean_nb_steps_after_quad_conv(fmpz_t nb, acb_srcptr a, slong prec);
}

Assuming that the Borchardt sequence starting from a converges
quadratically from the start, set nb such that nb steps are enough to
compute the Borchardt mean at precision prec.

\fun{
int borchardt_mean_quad_conv_is_reached(acb_srcptr a, slong prec);
}

Return 1 if the Borchardt sequence starting from a converges
quadratically from the start, and 0 otherwise.

\fun{
int borchardt_mean(acb_t r, acb_srcptr a, slong prec);
}

Set r to the Borchardt mean of the vector a with only good choices of
square roots and return 1. If a good choice of square roots cannot be
made at some point, return 0.


Theta characteristics are implemented as ulongs of length 2g of the
form $a_0 a_1 \cdots a_{g-1} b_0 b_1 \cdots b_{g-1}$. This notation
differs from Dupont's but is more convenient to work with. Vectors of
theta constants have size $2^{2g}$. The user must ensure that $2^{2g}$
fits in a ulong.

\fun{
ulong theta_char_get_a(ulong ch, slong g);
}  

\fun{
ulong theta_char_get_b(ulong ch, slong g);
}

\fun{
ulong theta_char_set_ab(ulong a, ulong b, slong g);
}

\fun{
int theta_char_dot_product(ulong a, ulong b, slong g);
}

Return the bitcount of the bitwise-and \code{a&b}.

\fun{
int theta_char_is_even(ulong ch, slong g);
}

\fun{
slong theta_char_get_label_g2(ulong ch);
}

\fun{
ulong theta_char_set_label_g2(slong label);
}

Conversions between theta characteristics and genus 2 Dupont labels.

\fun{
void theta_duplication(acb_ptr th2_2tau, acb_srcptr th_tau, slong prec);
}

Apply the duplication formula to \code{th_tau}.

\fun{
int theta_0123_naive_B(fmpz_t B, const acb_mat_t tau, slong prec);
}

Set B to an integer such that the genus 2 theta constants of
characteristics 0, 1, 2, 3 can be computed within prec bits of
precision using partial sums over a square of size $B$, and return
1. Return 0 if no positive lower bound for the eigenvalues of Im(tau)
can be computed.

\fun{
int theta_0123_naive(acb_ptr th, const acb_mat_t tau, slong prec);
}

Compute the genus 2 theta constants of characteristics 0, 1, 2, 3 at
tau using the naive algorithm, which is quadratic in prec, and return
1. Return 0 if we fail to compute B as above.

\fun{
int theta2_naive(acb_ptr th, const acb_mat_t tau, slong prec);
}

Compute the squares of all genus 2 theta constants at tau using
\code{theta_0123_naive} at tau/2 and the duplication formula. Return 1
upon success and 0 otherwise.

The following functions assume that tau lies in the fundamental domain.

\fun{
int theta2_inverse(acb_mat_t tau, acb_srcptr th, slong prec);
}

Assuming that th contains the squares of genus 2 theta constants at
tau for some tau in the fundamental domain up to a common scalar
factor, compute tau using Borchardt means and return 1. Return 0 if
one of the Borchardt means cannot be computed. This algorithm is
quasi-linear in the precision for fixed tau.

\fun{
int theta_0123half_inverse(acb_mat_t tau, acb_srcptr th_half, slong prec);
}

Same as above, but starting with the theta constants of
characteristics 0, 1, 2, 3 at tau/2 instead.

\fun{
int theta_0123half_inverse_diff(acb_mat_t dtau, const acb_mat_t tau, acb_srcptr th_half,
				slong prec);
}

Same as \code{theta_0123half_inverse}, but also compute approximations
of the derivatives: \code{dtau[i][j-1]} should contain an
approximation of the derivative of \code{tau_i} with respect to
\code{th_half[j]} for $j\in\{1,2,3\}$, and is computed using a finite
difference. Return 1 upon success, 0 otherwise. \code{th_half} is
assumed to be normalized with first value 1.

\fun{                              
int theta_newton_step(acb_ptr th_half, const acb_mat_t tau, acb_srcptr th_half_approx,
		      slong prec);
}

Perform one step in a Newton iteration to compute theta constants at
tau/2 to precision prec. \code{th_half_approx} is assumed to contain
the same values to precision roughly prec/2. Return 1 upon success,
otherwise 0.

\fun{                    
int theta_newton(acb_ptr th, const acb_mat_t tau, slong prec);
}

Attempt to compute squares of theta constants, up to a scalar factor,
at tau to precision prec using a Newton iteration. Return 1 upon
success, 0 otherwise. This algorithm is heuristic, but should be
quasi-linear in the precision for fixed tau.

\section{Tests}

\fun{t-acb_mat_set_arb_arb}

Test compatibility with \code{acb_mat_get_real} and
\code{acb_mat_get_imag} on inputs constructed using
\code{arb_mat_randtest}. 10000 iterations.

\fun{t-arb_mat_minkowski_reduce}

Generate random exact Minkowski-reduced matrices for $g=2$ using
\code{fmpq_randtest}, lying sometimes on the boundary. Test
\code{arb_mat_is_minkowski_reduced} on these inputs. Then, apply a
random transformation in SL$_2(\mathbb{Z})$ and apply
\code{arb_mat_minkowski_reduce}. The result must overlap the original
matrix. 10000 iterations.

\fun{t-sp2gz_is_correct}

Test \code{sp2gz_is_correct} on random input produced by
\code{sp2gz_randtest_triangular}, \code{sp2gz_randtest_diagonal} and
\code{sp2gz_randtest} for $g$ between 1 and 10. 1000 iterations.

\fun{t-sp2gz_mul}

Select $g$ between 1 and 10, generate random matrices using
\code{sp2gz_randtest}. Test associativity of multiplication and
correctness of output, aliasing included. 500 iterations.

\fun{t-sp2gz_inv}

Check that applying \code{sp2gz_inv}, then \code{sp2gz_mul} gives the
identity. Aliasing included. 500 iterations.

\fun{t-siegel_halfspace_randtest}

Select $g$ between 1 and 10, and check that the output of
\code{siegel_halfspace_randtest} (at medium to high precision) have
symmetric real and imaginary parts, and that the trace and determinant
of the imaginary part are positive. 1000 iterations.

\fun{t-siegel_transform}

Select $g$ between 1 and 10, and check associativity of Siegel
transformations on random input produced by
\code{siegel_halfspace_randtest} (high precision) and
\code{sp2gz_randtest}. Insufficient precision to invert is considered
a failure. Aliasing included. 100 iterations.

\fun{t-siegel_star}

Select $g$ between 1 and 10, and test the cocycle relation on random
input produced by \code{siegel_halfspace_randtest} (high precision)
and \code{sp2gz_randtest}. Insufficient precision to invert is
considered a failure. 1000 iterations.

\fun{t-siegel_reduce_real}

Select $g$ between 1 and 10, and check that the result of
\code{siegel_reduce_real} applied on random input produced by
\code{siegel_halfspace_randtest} (with higher precision than error
tolerance) satisfies \code{siegel_is_real_reduced}. 1000 iterations.

\fun{t-siegel_test_matrix}

For $g\in\{1,2\}$, check that the test matrices are all distinct and
symplectic.

\fun{t-siegel_fundamental_domain}

Fix $g=2$ and generate random input using
\code{sp2gz_halfspace_randtest} at very high precision. Apply a random
symplectic transformation, then
\code{siegel_fundamental_domain}. Check that the result satisfies
\code{siegel_is_in_fundamental_domain}. No comparison with the initial
input is made due to boundary issues. Insufficient precision in the
algorithm is considered a failure. 100 iterations.

\fun{t-borchardt_mean_m0_M0}

Generate four random complex numbers with positive real part using
\code{acb_randtest_precise}, and scale so that an element becomes
1. Apply \code{borchardt_mean_m0} and \code{borchardt_mean_M0}. Check
that both are positive, and that m0 (resp. M0) is smaller
(resp. larger) than the absolute values of the entries. 10000
iterations.

\fun{t-borchardt_mean}

Generate positive real numbers x, y using \code{arb_randtest_precise}
and check that the Borchardt mean of [x, x, y, y] overlaps the real
AGM computed by \code{arb_agm}. Insufficient precision is considered a
failure. 10000 iterations.

\fun{t-theta_char_is_even}

Check that the even theta characteristics in genus 2 indeed correspond
to the usual Dupont labels.

\fun{t-theta_0123_naive}

Generate a random tau using \code{siegel_halfspace_randtest} at medium
to high precision and apply \code{theta_0123_naive} at both tau and
$2*$tau. Check that the output is compatible with the duplication
formula. 10000 iterations.

\fun{t-theta_0123half_inverse}

Generate random tau using \code{siegel_halfspace_randtest} at medium
to high precision and reduce it to the fundamental domain. Compute
theta constants at tau/2 using \code{theta_0123_naive}. Apply
\code{theta_0123half_inverse} and check that the result overlaps the
initial tau. 500 iterations.

\fun{t-theta2_inverse}

Generate random tau using \code{siegel_halfspace_randtest} at medium
to high precision and reduce it to the fundamental domain. Compute
squares of theta constants using \code{theta2_naive}, apply
\code{theta2_inverse}, and check that the result overlaps the initial
tau. 

\end{document}
